/// Code formatting utilities for generated Rust code
use std::collections::HashSet;

/// Format generated code with proper imports and structure
pub fn format_generated_code(
    imports: &HashSet<String>,
    state_struct: &str,
    node_functions: &str,
    executor: &str,
    original_python: Option<&str>,
) -> String {
    let mut code = String::new();

    // Add file header
    code.push_str("// Generated by langgraph-rs\n");
    code.push_str("// Do not edit this file manually\n\n");

    // Add original Python as reference if available
    if let Some(python_code) = original_python {
        code.push_str("/*\nOriginal Python code:\n\n");
        code.push_str(python_code);
        code.push_str("\n*/\n\n");
    }

    // Add standard imports
    code.push_str("use serde::{Deserialize, Serialize};\n");
    code.push_str("use anyhow::{Result, Context};\n");
    code.push_str("use async_trait::async_trait;\n");

    // Add custom imports
    for import in imports {
        code.push_str(&format!("use {};\n", import));
    }

    code.push_str("\n");

    // Add state struct
    code.push_str(&state_struct);
    code.push_str("\n\n");

    // Add node functions
    code.push_str(&node_functions);
    code.push_str("\n\n");

    // Add executor
    code.push_str(&executor);
    code.push_str("\n\n");

    // Add main entry point
    code.push_str(
        r#"/// Main entry point for executing the graph
pub async fn run_graph(initial_state: GraphState) -> Result<GraphState> {
    execute_graph(initial_state).await
}
"#,
    );

    code
}

/// Add proper indentation to code
pub fn indent(code: &str, level: usize) -> String {
    let indent_str = "    ".repeat(level);
    code.lines()
        .map(|line| {
            if line.trim().is_empty() {
                String::new()
            } else {
                format!("{}{}", indent_str, line)
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Generate documentation comment
pub fn doc_comment(text: &str) -> String {
    text.lines()
        .map(|line| format!("/// {}", line))
        .collect::<Vec<_>>()
        .join("\n")
}
